# 实验报告

## 一、实验目的

- 掌握通过几何相似变换（基于生成元思想）构造分形曲线的方法。
- 理解如何利用复数表示平面点，并用迭代方法生成科赫曲线和闵可夫斯基香肠曲线。
- 熟悉分形曲线的生成原理及其可视化方法。

## 二、实验过程

1. **算法设计与实现**
   - 采用复数表示平面上的点，利用复数运算实现线段的缩放、旋转和平移。
   - 实现 `koch_generator(level)` 和 `minkowski_generator(level)` 两个函数，分别生成科赫曲线和闵可夫斯基香肠曲线的点序列。
   - 每次迭代，对当前所有线段应用生成元规则，插入新点，形成下一层级的点序列。
   - **（可选）在此插入你认为关键的代码片段：**
     ```python
     # 例如，科赫曲线生成函数的主要部分
     def koch_generator(u, level):
         # ...你的实现...
     # 科赫曲线生成核心逻辑
p0 = start
p1 = start + vec / 3
p2 = p1 + (vec / 3) * np.exp(1j * np.pi/3)  # 60度旋转
p3 = start + 2 * vec / 3
p4 = end
      # 闵可夫斯基香肠生成核心逻辑
p0 = start
p1 = start + vec / 8
p2 = p1 + (vec / 8) * 1j      # 向上
p3 = p2 + vec / 8
p4 = p3 + (vec / 8) * (-1j)   # 向下
p5 = p4 + (vec / 8) * (-1j)   # 继续向下
p6 = p5 + vec / 8
p7 = p6 + (vec / 8) * 1j      # 向上
p8 = end
     ```

2. **绘图与展示**
   - 使用 `matplotlib` 绘制不同迭代层级下的分形曲线。
   - 采用子图网格展示不同层级的分形效果，设置合适的标题和坐标比例。
   - **（可选）插入绘图相关的代码片段：**
     ```python
     # 例如，绘制分形曲线的代码
     plt.plot(points.real, points.imag)
     fig, axs = plt.subplots(2, 2, figsize=(10, 10))
for i in range(4):
    points = generator(init_u, i+1)
    ax = axs[i//2, i%2]
    ax.plot(points.real, points.imag, 'k-', lw=1)  # 黑色实线
    ax.set_title(f"Level {i+1}", fontsize=12)
    ax.axis('equal')
    ax.axis('off')
plt.tight_layout()
     ```

3. **遇到的问题与解决方法**
   - （请在此填写你在实现过程中遇到的具体问题及解决思路，如复数运算、点插入顺序、图像显示等。）
复数数组拼接效率低
现象：递归拼接大量小数组时速度明显下降
解决：预分配数组空间改为列表收集+最终转换

## 三、结果展示

### 1. 科赫曲线（Koch Curve）

- 插入生成的科赫曲线各层级图像（如 `koch_curves.png`）。
- ![koch_curves](https://github.com/user-attachments/assets/e29d0669-14c1-4442-9bce-1f6b62ef1069)!
- 简要说明各层级分形结构的变化。
- Level 1：初始线段被分为4段，中间两段形成等边三角形，整体呈现"凸起"形状。
Level 2：对Level 1的每个线段再次应用相同变换，产生更小的凸起，曲线开始显现分形特征。
Level 3：每个小线段继续被细分，曲线变得更加复杂，自相似性明显。
Level 4：曲线已具有明显的分形特征，边缘呈现精细的锯齿结构。
- **（可选）插入生成图像的代码片段。**
def koch_generator(u, level):
    if level == 0:
        return u
    
    points = np.array([], dtype=np.complex128)
    for i in range(len(u)-1):
        start = u[i]
        end = u[i+1]
        vec = end - start
        
        p0 = start
        p1 = start + vec / 3
        p2 = p1 + vec / 3 * np.exp(1j * np.pi/3)
        p3 = start + 2 * vec / 3
        p4 = end
        
        segment = np.array([p0, p1, p2, p3, p4])
        points = np.concatenate((points, segment[:-1])) if points.size else segment[:-1]
    
    points = np.concatenate((points, [end]))
    return koch_generator(points, level-1)
  
### 2. 闵可夫斯基香肠曲线（Minkowski Sausage）

- 插入生成的闵可夫斯基香肠曲线各层级图像（如 `minkowski_sausages.png`）。
- 简要说明各层级分形结构的变化。
- Level 1：线段被替换为8段组成的复杂路径，形成类似"香肠"的凹凸结构。
Level 2：每个小线段再次被细分，曲线开始呈现更复杂的波浪形态。
Level 3：自相似特征显现，曲线表面出现更小尺度的凹凸结构。
Level 4：曲线变得极为复杂，填充空间的能力显著增强。
- **（可选）插入生成图像的代码片段。**
def minkowski_generator(u, level):
    if level == 0:
        return u
    
    points = np.array([], dtype=np.complex128)
    for i in range(len(u)-1):
        start = u[i]
        end = u[i+1]
        vec = end - start
        
        p0 = start
        p1 = start + vec / 8
        p2 = p1 + vec / 8 * 1j
        p3 = p2 + vec / 8
        p4 = p3 + vec / 8 * (-1j)
        p5 = p4 + vec / 8 * (-1j)
        p6 = p5 + vec / 8
        p7 = p6 + vec / 8 * 1j
        p8 = end
        
        segment = np.array([p0, p1, p2, p3, p4, p5, p6, p7, p8])
        points = np.concatenate((points, segment[:-1])) if points.size else segment[:-1]
    
    points = np.concatenate((points, [end]))
    return minkowski_generator(points, level-1)
  
## 四、结果分析与思考

- 分析分形曲线的自相似性和复杂度随迭代层级的变化。
- 讨论基于复数的迭代方法与传统递归方法的优缺点。
- 思考初始线段方向、生成元参数等对分形形态的影响。
- （可选）尝试生成科赫雪花或修改生成元，观察分形变化。

---

**注：请在每一部分补充你自己的实验内容、图像、分析和关键代码。**
